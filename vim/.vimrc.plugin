" ==========================
" Plugin settings
" ==========================

" ---------------
" open-browser
" ---------------
let g:openbrowser_search_engines = {
    \   'caniuse': 'http://caniuse.com/#search={query}',
    \}
let g:netrw_nogx = 1
let g:openbrowser_open_filepath_in_vim = 0
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)
command! OpenBrowserCurrent execute "OpenBrowser" "file://" . expand('%:p:gs?\\?/?')
command! CanIuse execute ":OpenBrowserSmartSearch" "-caniuse" input('Can I use?: ')

"------------------------------------
" vim-airline
"------------------------------------
" let g:airline#extensions#tabline#enabled = 1
" let g:airline_powerline_fonts = 1
" if !exists('g:airline_symbols')
"   let g:airline_symbols = {}
" endif
" let g:airline_symbols.space = '\ua0'
" set laststatus=2


"------------------------------------
" lightline
"------------------------------------

set t_Co=256
set laststatus=2

let g:lightline = {
      \ 'colorscheme': 'wombat',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
      \   'right': [ [ 'syntastic', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
      \ },
      \ 'component_function': {
      \   'fugitive': 'LightLineFugitive',
      \   'filename': 'LightLineFilename',
      \   'fileformat': 'LightLineFileformat',
      \   'filetype': 'LightLineFiletype',
      \   'fileencoding': 'LightLineFileencoding',
      \   'mode': 'LightLineMode',
      \   'ctrlpmark': 'CtrlPMark',
      \ },
      \ 'component_expand': {
      \   'syntastic': 'SyntasticStatuslineFlag',
      \ },
      \ 'component_type': {
      \   'syntastic': 'error',
      \ },
      \ 'separator': { 'left': "\ue0b0", 'right': "\ue0b2" },
      \ 'subseparator': { 'left': "\ue0b1", 'right': "\ue0b3" },
      \ }

function! LightLineModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightLineReadonly()
  return &ft !~? 'help' && &readonly ? 'RO' : ''
endfunction

function! LightLineFilename()
  let fname = expand('%:t')
  return fname == 'ControlP' ? g:lightline.ctrlp_item :
        \ fname == '__Tagbar__' ? g:lightline.fname :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'unite' ? unite#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
endfunction

function! LightLineFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      let mark = ''  " edit here for cool mark
      let _ = fugitive#head()
      return strlen(_) ? mark._ : ''
    endif
  catch
  endtry
  return ''
endfunction

function! LightLineFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! LightLineFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! LightLineFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! LightLineMode()
  let fname = expand('%:t')
  return fname == '__Tagbar__' ? 'Tagbar' :
        \ fname == 'ControlP' ? 'CtrlP' :
        \ fname == '__Gundo__' ? 'Gundo' :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ fname =~ 'NERD_tree' ? 'NERDTree' :
        \ &ft == 'unite' ? 'Unite' :
        \ &ft == 'vimfiler' ? 'VimFiler' :
        \ &ft == 'vimshell' ? 'VimShell' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! CtrlPMark()
  if expand('%:t') =~ 'ControlP'
    call lightline#link('iR'[g:lightline.ctrlp_regex])
    return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
          \ , g:lightline.ctrlp_next], 0)
  else
    return ''
  endif
endfunction

let g:ctrlp_status_func = {
  \ 'main': 'CtrlPStatusFunc_1',
  \ 'prog': 'CtrlPStatusFunc_2',
  \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
  return lightline#statusline(0)
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
  return lightline#statusline(0)
endfunction

augroup AutoSyntastic
  autocmd!
  autocmd BufWritePost *.c,*.cpp call s:syntastic()
augroup END
function! s:syntastic()
  SyntasticCheck
  call lightline#update()
endfunction

let g:unite_force_overwrite_statusline = 0
let g:vimfiler_force_overwrite_statusline = 0
let g:vimshell_force_overwrite_statusline = 0

"------------------------------------
" vim-indent-guides
"------------------------------------
let g:indent_guides_enable_on_vim_startup = 1
let g:vimfiler_enable_auto_cd = 1
let g:indent_guides_color_change_percent = 30
let g:indent_guides_guide_size=1
" 除外するFileType
let g:indent_guides_exclude_filetypes = ['help', 'vimfiler', 'unite']

"------------------------------------
" vim-trailing-whitespace
"------------------------------------
  " uniteでスペースが表示されるので、設定でOFFにします。
  let g:extra_whitespace_ignored_filetypes = ['unite', 'vimfiler']

"------------------------------------
" Helpを日本語化
"------------------------------------
set helplang& helplang=ja,en

"------------------------------------
" toggle.vim
"------------------------------------
imap <C-A> <Plug>ToggleI
nmap <C-A> <Plug>ToggleN
vmap <C-A> <Plug>ToggleV

let g:toggle_pairs = { 'and':'or', 'or':'and', 'if':'unless', 'unless':'if', 'yes':'no', 'no':'yes', 'enable':'disable', 'disable':'enable', 'pick':'reword', 'reword':'fixup', 'fixup':'squash', 'squash':'edit', 'edit':'exec', 'exec':'pick' }

" ---------------
" unite.vim
" ---------------
nnoremap   [unite]   <Nop>
nmap    <Leader>u [unite]

nnoremap [unite]u  :<C-u>Unite -no-split -no-resize -start-insert<Space>

let g:unite_source_file_mru_limit=200
let g:unite_source_rec_async_command='pt --nocolor --nogroup -g .'
let g:unite_source_rec_max_cache_files=5000
let g:neoyank#limit = 1000
let g:neoyank#file = $HOME.'/.vim/yankring.txt'

call unite#custom#source(
      \ 'buffer,file_rec/async,file_rec', 'matchers',
      \ ['converter_tail', 'matcher_default'])
call unite#custom#source(
      \ 'file_rec/async,file_rec', 'converters',
      \ ['converter_file_directory'])

"全部のせ
nnoremap <silent> [unite]a :<C-u>UniteWithCurrentDir -no-split -no-resize -start-insert -buffer-name=files buffer file_mru bookmark file<CR>
" ファイル一覧
nnoremap <silent> [unite]f :<C-u>Unite -no-split -no-resize -start-insert -buffer-name=files file<CR>
" バッファー一覧
nnoremap <silent> [unite]b :<C-u>Unite -no-split -no-resize -start-insert buffer<CR>
" 常用セット
nnoremap <silent> [unite]u :<C-u>Unite -no-split -no-resize -start-insert buffer file_mru<CR>
" 最近使用したファイル一覧
nnoremap <silent> [unite]m :<C-u>Unite -no-split -no-resize -start-insert file_mru<CR>
" 現在のバッファのカレントディレクトリからファイル一覧
nnoremap <silent> [unite]d :<C-u>UniteWithBufferDir -no-split -no-resize -start-insert file<CR>
" file_recしたディレクトリを表示
nnoremap <silent> [unite]r :<C-u>Unite -start-insert file_rec/async:!<CR>
" 検索行を一覧
nnoremap <silent> [unite]; :<C-u>Unite line<CR>
" ヤンクヒストリ一覧
nnoremap <silent> [unite]y :<C-u>Unite history/yank<CR>
" ヘルプをuniteで表示
nnoremap <silent> [unite]h :<C-u>Unite -no-split -buffer-name=help help<CR>
" テキスト、ソースをoutline表示
nnoremap <silent> [unite]o :<C-u>Unite -no-split -no-resize outline<CR>


augroup unite_settings
  autocmd!
  autocmd FileType unite call s:unite_my_settings()
augroup END

function! s:unite_my_settings() abort

  " ESCキーを2回押すと終了する
  nmap <buffer> <ESC> <Plug>(unite_exit)
  nmap <buffer> <ESC><ESC> <Plug>(unite_exit)
  imap <buffer> jj <Plug>(unite_insert_leave)
  nnoremap <silent><buffer> <C-k> :<C-u>call unite#mappings#do_action('preview')<CR>
  imap <buffer> <C-w> <Plug>(unite_delete_backward_path)
  let g:unite_enable_start_insert = 1

  " ウィンドウを分割して開く
  nnoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
  inoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')

  " ウィンドウを縦に分割して開く
  nnoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
  inoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')

endfunction

call unite#custom_default_action('source/bookmark/directory' , 'vimfiler')

" grep検索
nnoremap <silent> <Leader>g :<C-u>Unite grep:. -buffer-name=search-buffer<CR>
" ディレクトリを指定してgrep
nnoremap <silent> <Leader>dg :<C-u>Unite grep -buffer-name=search-buffer<CR>
" カーソル位置の単語をgrep検索
nnoremap <silent> <Leader>cg :<C-u>Unite grep:. -buffer-name=search-buffer<CR><C-R><C-W>
" grep検索結果の再呼出
nnoremap <silent> <Leader>r :<C-u>UniteResume search-buffer<CR>
" Bookmarkを開く
nnoremap <silent> <Leader><Leader>b :<C-u>Unite bookmark<CR>
" Bookmark追加
nnoremap <silent> <Leader><Leader>B :<C-u>UniteBookmarkAdd<CR>

let g:unite_enable_ignore_case = 1
let g:unite_enable_smart_case = 1
let g:unite_source_grep_max_candidates = 200

" unite grepにpt を使う
if executable('pt')
  let g:unite_source_grep_command = 'pt'
  let g:unite_source_grep_default_opts = '--nogroup --nocolor'
  let g:unite_source_grep_recursive_opt = ''
  let g:unite_source_grep_encoding = 'utf-8'
endif

" snippet一覧
" nnoremap <silent> [unite]s :<C-u>Unite snippet<CR>

" ---------------
" vimfiler.vim
" ---------------
nnoremap [vimfiler] <Nop>
nmap <Leader>f [vimfiler]

"IDE風
noremap <silent> [vimfiler]t :<C-u>VimFilerBufferDir -winwidth=35 -split -no-quit -simple -toggle<CR>

"デフォルトのfilerに設定
let g:vimfiler_as_default_explorer = 1
"セーフモード無効で起動
let g:vimfiler_safe_mode_by_default = 0
" Like Textmate icons.
let g:vimfiler_tree_leaf_icon = '⋮'
let g:vimfiler_tree_opened_icon = '▾'
let g:vimfiler_tree_closed_icon = '▸'
let g:vimfiler_file_icon = '-'
let g:vimfiler_marked_file_icon = '*'

" 現在のディレクトリ
nnoremap <silent> [vimfiler]e :<C-u>VimFilerBufferDir -quit<CR>

"vimfiler上でのキーマッピング
augroup vimfiller_setting
  autocmd!
  autocmd FileType vimfiler call s:vimfiler_my_settings()
augroup END
function! s:vimfiler_my_settings()
  nmap <buffer> q <Plug>(vimfiler_exit)
  nmap <buffer> Q <Plug>(vimfiler_hide)
  nnoremap <buffer> <C-r> <Plug>(vimfiler_redraw_screen)
  nmap <buffer> <C-q> <Plug>(vimfiler_quick_look)
  nmap <buffer> <C-w> <Plug>(vimfiler_switch_to_history_directory)
  setlocal nonumber
endfunction

" ---------------
" Gundo.vim
" ---------------
nnoremap <F5> :GundoToggle<CR>

" ---------------
" vim-markdown
" ---------------

augroup MyMarkdown
  autocmd!
  autocmd BufRead,BufNewFile *.md set filetype=markdown
  " mlでlist-item追加
  autocmd FileType markdown nnoremap <buffer> ml <C-u>for i in range(v:count1) \| call append(line('.'), '*') \| endfor<CR>
augroup END

" ---------------
" quickrun.vim
" ---------------

let g:quickrun_config = get(g:, 'quickrun_config', {})
let g:quickrun_config._ = {
    \ 'runner'    : 'vimproc',
    \ 'runner/vimproc/updatetime' : 60,
    \ 'outputter' : 'error',
    \ 'outputter/error/success' : 'buffer',
    \ 'outputter/error/error'   : 'quickfix',
    \ 'outputter/buffer/split'  : ':rightbelow 8sp',
    \ 'outputter/buffer/close_on_empty' : 1,
    \ }

"<C-c> で実行を強制終了
" quickrun.vim が実行してない場合は<C-c>を呼び出す
augroup quickrunSettings
  autocmd!
  autocmd FileType qf nnoremap <silent><buffer>q :quit<CR>
augroup END
let g:quickrun_no_default_key_mappings = 1
nmap <Leader>r <Plug>(quickrun)
nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"

" ---------------
" syntastic
" ---------------
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_loc_list_height = 6
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_save = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_enable_signs=1

let g:airline#extensions#syntastic#enabled = 1

let g:syntastic_jade_checkers = ['jadelint']
let g:syntastic_javascript_checkers = ['eslint']
let g:syntastic_scss_checkers = ['scss_lint']
let g:syntastic_css_checkers = ['css']
let g:syntastic_vim_checkers = ['vint']

let g:syntastic_mode_map = {
      \ 'mode': 'active',
      \ 'active_filetypes': [],
      \ 'passive_filetypes': []
      \ }

let g:hier_enabled=1

" ---------------
" watchdogs
" ---------------

" 書き込み後にシンタックスチェックを行う
" let g:watchdogs_check_BufWritePost_enable = 1
" let g:watchdogs_check_BufWritePost_enables = {
"   \'scss':0,
"   \}
" let g:watchdogs_check_CursorHold_enable = 1
" let g:watchdogs_check_CursorHold_enables = {
"   \'scss':0,
"   \}

"JavaScript {{{
" let s:config = {
" \  'watchdogs_checker/_' : {
" \    'hook/u_nya_/enable' : 1,
" \    'hook/inu/enable' : 0,
" \    'hook/unite_quickfix/enable' : 0,
" \    'hook/echo/enable' : 0,
" \    'hook/back_buffer/enable' : 0,
" \    'hook/close_unite_quickfix/enable' : 0,
" \    'hook/close_buffer/enable_exit' : 0,
" \    'outputter/quickfix/open_cmd' : '',
" \    'hook/redraw_unite_quickfix/enable_exit' : 0,
" \    'hook/close_unite_quickfix/enable_exit' : 1,
" \  },
" \'javascript/watchdogs_checker' : {
"         \'type' : 'watchdogs_checker/eslint',
"         \},
" \'css/watchdogs_checker' : {
"         \'type' : 'watchdogs_checker/csslint',
"         \},
" \'vim/watchdogs_checker' : {
"         \'type' : 'watchdogs_checker/vint',
"         \}
" \}

" call extend(g:quickrun_config, s:config)
" unlet s:config
" }}}


" if !has('vim_starting')
  " call watchdogs#setup(g:quickrun_config)
" endif

" If syntax error, cursor is moved at line setting sign.
" let g:qfsigns#AutoJump = 1
" If syntax error, view split and cursor is moved at line setting sign.
" let g:qfsigns#AutoJump = 2


" ---------------
" VimCSS3Syntax
" ---------------
augroup VimCSS3Syntax
  autocmd!

  autocmd FileType css setlocal iskeyword+=-
augroup END


" ---------------
" Sass-compile
" ---------------

let $PATH=$PATH.'path_to_compass'

" 編集したファイルから遡るフォルダの最大数
let g:sass_compile_cdloop = 5

" ファイル保存時に自動コンパイル（1で自動実行）
let g:sass_compile_auto = 1

" 自動コンパイルを実行する拡張子
let g:sass_compile_file = ['scss', 'sass']

" cssファイルが入っているディレクトリ名（前のディレクトリほど優先）
let g:sass_compile_cssdir = ['css', 'stylesheet', 'stylesheets']

" コンパイル実行前に実行したいコマンドを設定
" 例：growlnotifyによる通知
" let g:sass_compile_beforecmd = "growlnotify -t 'sass-compile.vim' -m 'start sass compile.'"
let g:sass_compile_beforecmd = ''

" コンパイル実行後に実行したいコマンドを設定
" 例：growlnotifyによる通知(${sasscompileresult}は実行結果)
" let g:sass_compile_aftercmd = "growlnotify -t 'sass-compile.vim' -m ${sasscompileresult}"
let g:sass_compile_aftercmd = ''

" ---------------
" vim-easy-align
" ---------------

" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)



" ---------------
" vim-jade
" ---------------
augroup vimJadeSetting
  autocmd!
  autocmd BufNewFile,BufRead *.jade  setf jade
  autocmd BufNewFile,BufRead *.jade  set tabstop=2 shiftwidth=2 expandtab
augroup END

let g:quickrun_config['jade']={'command': 'jade', 'cmdopt': '-P', 'exec': ['%c &o < %s']}


" ---------------
" vim-airline
" ---------------
let g:airline#extensions#tabline#enabled = 1

" ---------------
" tmuxline
" ---------------
" let g:airline#extensions#tmuxline#enabled = 1
" let g:tmuxline_theme = 'airline'
